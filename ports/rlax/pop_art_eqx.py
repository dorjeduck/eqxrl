# Copyright 2019 DeepMind Technologies Limited. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""An online Q-learning agent with PopArt on Catch with large rewards.

Learns faster with PopArt than without.
"""

import collections
from absl import app
from absl import flags
from bsuite.environments import catch
from bsuite.utils import wrappers

import equinox as eqx
from rlax import PopArtState

import jax
import jax.numpy as jnp
import optax
import rlax
import chex
from typing import Tuple

import numpy as np
import experiment_eqx

ActorOutput = collections.namedtuple("ActorOutput", "actions")
Transition = collections.namedtuple("Transition", "obs_tm1 a_tm1 r_t discount_t obs_t")

FLAGS = flags.FLAGS
flags.DEFINE_integer("seed", 42, "Random seed.")
flags.DEFINE_float("reward_scale", 10000, "Reward scale on Catch.")
flags.DEFINE_integer("train_episodes", 2000, "Number of train episodes.")
flags.DEFINE_integer("num_hidden_units", 50, "Number of network hidden units.")
flags.DEFINE_float("epsilon", 0.01, "Epsilon-greedy exploration probability.")
flags.DEFINE_float("discount_factor", 0.99, "Q-learning discount factor.")
flags.DEFINE_float("learning_rate", 0.005, "Optimizer learning rate.")
flags.DEFINE_float("pop_art_step_size", 3e-3, "PopArt normalization step size.")
flags.DEFINE_integer("eval_episodes", 100, "Number of evaluation episodes.")
flags.DEFINE_integer("evaluate_every", 50, "Number of episodes between evaluations.")


def pop_eqx(linear: eqx.nn.Linear, old: PopArtState, new: PopArtState) -> eqx.nn.Linear:
    """Preserves outputs precisely for Equinox Linear layers.

    Args:
        linear: The Equinox Linear layer to preserve.
        old: The old PopArt state.
        new: The new PopArt state.

    Returns:
        A new Equinox Linear layer with updated weights and biases.
    """
    w_new = linear.weight * jnp.broadcast_to(old.scale / new.scale, linear.weight.shape)
    b_new = (old.scale * linear.bias + old.shift - new.shift) / new.scale
    
    linear =  eqx.nn.Linear(
        in_features=linear.in_features,
        out_features=linear.out_features,
        key=jax.random.key(0),  # Dummy key, not relevant here
    )

    linear = eqx.tree_at(lambda l: l.weight, linear, w_new)
    linear = eqx.tree_at(lambda l: l.bias, linear, b_new)

    return linear


def popart_eqx(
    num_outputs: int, step_size: float, scale_lb: float, scale_ub: float, axis_name=None
):
    """Generates functions giving initial PopArt state and update rule.

    Args:
      num_outputs: The number of outputs generated by the linear we're preserving.
      step_size: The step size for learning the scale & shift parameters.
      scale_lb: Lower bound for the scale.
      scale_ub: Upper bound for the scale.
      axis_name: What axis to aggregate over, if str. If passed an iterable,
        aggregates over multiple axes. Defaults to no aggregation, i.e. None.

    Returns:
      A tuple of:
        initial_state: A function returning the initial PopArt state.
        popart_update: A function updating the PopArt state and parameters
        of the preceding linear.
    """

    def initial_state():
        return PopArtState(
            jnp.zeros([num_outputs]), jnp.ones([num_outputs]), jnp.ones([num_outputs])
        )

    def popart_update(
        linear: eqx.nn.Linear,
        state: PopArtState,
        targets: chex.Array,
        indices: chex.Array,
    ) -> Tuple[eqx.nn.Linear, PopArtState]:
        """Computes the PopArt update.

        Args:
          linear: The Equinox Linear layer to preserve.
          state: The current PopArt state.
          targets: Values whose distribution to learn.
          indices: For each target, which shift and scale element to adjust.

        Returns:
          A tuple of:
            new_linear: The new Equinox Linear layer, preserving outputs.
            new_state: The new PopArt state.
        """
        # Disables Popart if step_size is None
        if step_size is None:
            return linear, state

        # Adaptively rescale targets.
        state_new = rlax.art(
            state, targets, indices, step_size, scale_lb, scale_ub, axis_name
        )

        # Preserve outputs precisely.
        linear_new = pop_eqx(linear, state, state_new)
        return linear_new, state_new

    return initial_state, popart_update


def build_network(
    obs_shape, num_hidden_units: int, num_actions: int, key
) -> eqx.Module:
    """Factory for a simple MLP network for approximating Q-values."""

    class QNetwork(eqx.Module):
        layers: list

        def __init__(self, in_features, num_hidden_units, num_actions, key):
            key1, key2 = jax.random.split(key)
            self.layers = [
                eqx.nn.Linear(
                    in_features=in_features, out_features=num_hidden_units, key=key1
                ),
                eqx.nn.Linear(
                    in_features=num_hidden_units, out_features=num_actions, key=key2
                ),
            ]

        def __call__(self, obs):
            obs = jnp.ravel(obs)  # Flatten the observation directly
            x = jax.nn.relu(self.layers[0](obs))
            return self.layers[1](x)

    in_features = int(np.prod(obs_shape))

    # Flatten the observation shape
    return QNetwork(
        in_features=in_features,  
        num_hidden_units=num_hidden_units,
        num_actions=num_actions,
        key=key,
    )


class TransitionAccumulator:
    """Simple Python accumulator for transitions."""

    def __init__(self):
        self._prev = None
        self._action = None
        self._latest = None

    def push(self, env_output, action):
        self._prev = self._latest
        self._action = action
        self._latest = env_output

    def sample(self, batch_size):
        assert batch_size == 1
        return Transition(
            self._prev.observation,
            self._action,
            self._latest.reward,
            self._latest.discount,
            self._latest.observation,
        )

    def is_ready(self, batch_size):
        assert batch_size == 1
        return self._prev is not None


class PopArtAgent:
    """An online Q-learning deep RL agent with PopArt."""

    def __init__(
        self,
        observation_spec,
        action_spec,
        num_hidden_units,
        epsilon,
        learning_rate,
        pop_art_step_size,
    ):
        self._observation_spec = observation_spec
        self._num_hidden_units = num_hidden_units
        self._action_spec = action_spec
        self._epsilon = epsilon

        # optimiser.
        self._optimizer = optax.adam(learning_rate)
        # Jitting for speed.
        self.actor_step = jax.jit(self.actor_step)
        self.learner_step = jax.jit(self.learner_step)
        self._initial_pop_art_state, self._pop_art_update = popart_eqx(
            num_outputs=1, step_size=pop_art_step_size, scale_lb=1e-5, scale_ub=1e5
        )

    def initial_models(self, key):

        return build_network(
            self._observation_spec.shape,
            self._num_hidden_units,
            self._action_spec.num_values,
            key,
        )

    def initial_actor_state(self):
        return ()

    def initial_learner_state(self, params):
        return self._optimizer.init(params), self._initial_pop_art_state()

    def actor_step(self, model, env_output, actor_state, key, evaluation):
        norm_q = model(env_output.observation)
        # This is equivalent to epsilon-greedy on the (unnormalized) Q-values
        # because normalization is linear, therefore the argmaxes are the same.
        train_a = rlax.epsilon_greedy(self._epsilon).sample(key, norm_q)
        eval_a = rlax.greedy().sample(key, norm_q)
        a = jax.lax.select(evaluation, eval_a, train_a)
        return ActorOutput(actions=a), actor_state

    def learner_step(self, model, data, learner_state, unused_key):
        opt_state, pop_art_state = learner_state
        dloss_dtheta, pop_art_state = jax.grad(self._loss, has_aux=True)(
            model, pop_art_state, *data
        )

        updates, opt_state = self._optimizer.update(dloss_dtheta, opt_state)
        model = eqx.apply_updates(model, updates)
        return model, (opt_state, pop_art_state)

    def _loss(self, model, pop_art_state, obs_tm1, a_tm1, r_t, discount_t, obs_t):
        """Loss function."""
        indices = jnp.array(0)  # Only one output for normalization.

        # Calculate targets by unnormalizing Q-values output by network.
        norm_q_t = model(obs_t)
        q_t = rlax.unnormalize(pop_art_state, norm_q_t, indices)
        target_tm1 = r_t + discount_t * jnp.max(q_t)

        # Update PopArt statistics and use them to update the network parameters to
        # POP (preserve outputs precisely). If there were target networks, the
        # parameters for these would also need to be updated.

        final_linear_layer = model.layers[
            -1
        ]  # Assuming the final layer is the last in the list
        updated_linear_layer, new_pop_art_state = self._pop_art_update(
            linear=final_linear_layer,
            state=pop_art_state,
            targets=target_tm1,
            indices=indices,
        )
        updated_model = eqx.tree_at(lambda m: m.layers[-1], model, updated_linear_layer)

        # Normalize target with updated PopArt statistics.
        norm_target_tm1 = rlax.normalize(new_pop_art_state, target_tm1, indices)

        # Calculate parameter update with normalized target and popped parameters.
        norm_q_t = updated_model(obs_t)
        norm_q_tm1 = updated_model(obs_tm1)
        td_error = jax.lax.stop_gradient(norm_target_tm1) - norm_q_tm1[a_tm1]
        return rlax.l2_loss(td_error), new_pop_art_state


def main(unused_arg):
    env = catch.Catch(seed=FLAGS.seed)
    env = wrappers.RewardScale(env, reward_scale=FLAGS.reward_scale)
    agent = PopArtAgent(
        observation_spec=env.observation_spec(),
        action_spec=env.action_spec(),
        num_hidden_units=FLAGS.num_hidden_units,
        epsilon=FLAGS.epsilon,
        learning_rate=FLAGS.learning_rate,
        pop_art_step_size=FLAGS.pop_art_step_size,
    )

    accumulator = TransitionAccumulator()
    experiment_eqx.run_loop(
        agent=agent,
        environment=env,
        accumulator=accumulator,
        seed=FLAGS.seed,
        batch_size=1,
        train_episodes=FLAGS.train_episodes,
        evaluate_every=FLAGS.evaluate_every,
        eval_episodes=FLAGS.eval_episodes,
    )


if __name__ == "__main__":
    app.run(main)
